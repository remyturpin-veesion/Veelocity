# v0.1 Foundation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Set up the foundational project structure with FastAPI backend, Flutter frontend, PostgreSQL database, and Docker Compose for local development.

**Architecture:** Single-user analytics platform with Python/FastAPI backend serving REST API, Flutter frontend for web/mobile, PostgreSQL for persistence. No auth, no Redis, no Celery - simplified stack. APScheduler will handle background sync (added in later version).

**Tech Stack:** Python 3.11, FastAPI, SQLAlchemy (async), PostgreSQL 15, Flutter, Riverpod, Docker Compose

---

## Task 1: Backend Project Structure

**Files:**
- Create: `backend/app/__init__.py`
- Create: `backend/app/main.py`
- Create: `backend/app/core/__init__.py`
- Create: `backend/app/core/config.py`
- Create: `backend/app/api/__init__.py`
- Create: `backend/app/api/v1/__init__.py`
- Create: `backend/app/api/v1/router.py`
- Create: `backend/requirements.txt`

**Step 1: Create directory structure**

```bash
mkdir -p backend/app/core backend/app/api/v1 backend/app/models backend/app/schemas backend/app/services backend/app/connectors backend/tests
```

**Step 2: Create requirements.txt**

```
# backend/requirements.txt
fastapi==0.109.0
uvicorn[standard]==0.27.0
sqlalchemy[asyncio]==2.0.25
asyncpg==0.29.0
pydantic-settings==2.1.0
httpx==0.26.0
apscheduler==3.10.4
alembic==1.13.1
pytest==7.4.4
pytest-asyncio==0.23.3
black==24.1.0
ruff==0.1.14
```

**Step 3: Create config.py**

```python
# backend/app/core/config.py
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    app_name: str = "Veelocity"
    debug: bool = False

    # Database
    database_url: str = "postgresql+asyncpg://veelocity:veelocity@localhost:5432/veelocity"

    # GitHub
    github_token: str | None = None

    # Linear
    linear_api_key: str | None = None

    # Sync
    deployment_patterns: str = "deploy,release,publish"  # Comma-separated

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"


settings = Settings()
```

**Step 4: Create empty __init__.py files**

```python
# backend/app/__init__.py
# backend/app/core/__init__.py
# backend/app/api/__init__.py
# backend/app/api/v1/__init__.py
```

(All empty files)

**Step 5: Create v1 router**

```python
# backend/app/api/v1/router.py
from fastapi import APIRouter

api_router = APIRouter()


@api_router.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy"}
```

**Step 6: Create main.py**

```python
# backend/app/main.py
from fastapi import FastAPI

from app.api.v1.router import api_router
from app.core.config import settings

app = FastAPI(
    title=settings.app_name,
    description="Developer analytics platform measuring DORA metrics",
    version="0.1.0",
)

app.include_router(api_router, prefix="/api/v1")


@app.get("/")
async def root():
    """Root endpoint."""
    return {"message": f"Welcome to {settings.app_name}"}
```

**Step 7: Verify backend starts**

```bash
cd backend
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Expected: Server starts on http://127.0.0.1:8000

**Step 8: Test health endpoint**

```bash
curl http://127.0.0.1:8000/api/v1/health
```

Expected: `{"status":"healthy"}`

**Step 9: Commit**

```bash
git add backend/
git commit -m "feat(backend): initialize FastAPI project structure

- Add core config with pydantic-settings
- Add health check endpoint at /api/v1/health
- Set up project structure for models, schemas, services, connectors"
```

---

## Task 2: Database Setup

**Files:**
- Create: `backend/app/core/database.py`
- Create: `backend/alembic.ini`
- Create: `backend/alembic/env.py`
- Create: `backend/alembic/script.py.mako`
- Create: `backend/alembic/versions/.gitkeep`

**Step 1: Create database.py**

```python
# backend/app/core/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase

from app.core.config import settings

engine = create_async_engine(settings.database_url, echo=settings.debug)

async_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)


class Base(DeclarativeBase):
    """Base class for all SQLAlchemy models."""
    pass


async def get_db() -> AsyncSession:
    """Dependency that provides a database session."""
    async with async_session_maker() as session:
        yield session
```

**Step 2: Initialize Alembic**

```bash
cd backend
alembic init alembic
```

**Step 3: Update alembic/env.py**

Replace the entire file content:

```python
# backend/alembic/env.py
import asyncio
from logging.config import fileConfig

from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

from alembic import context

from app.core.config import settings
from app.core.database import Base

# Import all models here so Alembic can detect them
# from app.models import *  # noqa (uncomment when models exist)

config = context.config
config.set_main_option("sqlalchemy.url", settings.database_url)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """Run migrations in 'online' mode with async engine."""
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    asyncio.run(run_async_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```

**Step 4: Update alembic.ini**

Edit `backend/alembic.ini`, change the sqlalchemy.url line to:

```ini
sqlalchemy.url = postgresql+asyncpg://veelocity:veelocity@localhost:5432/veelocity
```

**Step 5: Commit**

```bash
git add backend/app/core/database.py backend/alembic.ini backend/alembic/
git commit -m "feat(backend): add async SQLAlchemy and Alembic setup

- Add async database engine and session maker
- Configure Alembic for async migrations
- Base declarative class for models"
```

---

## Task 3: Docker Compose Setup

**Files:**
- Create: `infra/docker/docker-compose.yml`
- Create: `infra/docker/.env.example`
- Create: `backend/Dockerfile`
- Create: `Makefile`

**Step 1: Create directories**

```bash
mkdir -p infra/docker
```

**Step 2: Create Dockerfile**

```dockerfile
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**Step 3: Create docker-compose.yml**

```yaml
# infra/docker/docker-compose.yml
version: "3.8"

services:
  postgres:
    image: postgres:15
    container_name: veelocity-postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-veelocity}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-veelocity}
      POSTGRES_DB: ${POSTGRES_DB:-veelocity}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U veelocity"]
      interval: 5s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ../../backend
      dockerfile: Dockerfile
    container_name: veelocity-backend
    environment:
      DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-veelocity}:${POSTGRES_PASSWORD:-veelocity}@postgres:5432/${POSTGRES_DB:-veelocity}
      DEBUG: ${DEBUG:-false}
      GITHUB_TOKEN: ${GITHUB_TOKEN:-}
      LINEAR_API_KEY: ${LINEAR_API_KEY:-}
      DEPLOYMENT_PATTERNS: ${DEPLOYMENT_PATTERNS:-deploy,release,publish}
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - ../../backend:/app

volumes:
  postgres_data:
```

**Step 4: Create .env.example**

```bash
# infra/docker/.env.example
# Database
POSTGRES_USER=veelocity
POSTGRES_PASSWORD=veelocity
POSTGRES_DB=veelocity

# Application
DEBUG=true

# Connectors (add your tokens)
GITHUB_TOKEN=
LINEAR_API_KEY=

# Sync settings
DEPLOYMENT_PATTERNS=deploy,release,publish
```

**Step 5: Create Makefile**

```makefile
# Makefile
.PHONY: dev down logs shell-backend test migrate

# Development
dev:
	docker-compose -f infra/docker/docker-compose.yml up -d

down:
	docker-compose -f infra/docker/docker-compose.yml down

logs:
	docker-compose -f infra/docker/docker-compose.yml logs -f

shell-backend:
	docker-compose -f infra/docker/docker-compose.yml exec backend /bin/bash

# Backend
test:
	cd backend && pytest -v

migrate:
	cd backend && alembic upgrade head

migrate-create:
	cd backend && alembic revision --autogenerate -m "$(name)"

# Linting
lint:
	cd backend && ruff check app/

format:
	cd backend && black app/
```

**Step 6: Create .env from example**

```bash
cp infra/docker/.env.example infra/docker/.env
```

**Step 7: Test Docker Compose**

```bash
make dev
```

Wait for containers to start, then:

```bash
curl http://localhost:8000/api/v1/health
```

Expected: `{"status":"healthy"}`

**Step 8: Commit**

```bash
git add backend/Dockerfile infra/ Makefile
git commit -m "feat(infra): add Docker Compose for local development

- PostgreSQL 15 with health check
- Backend container with hot reload
- Makefile for common commands (dev, down, logs, test, migrate)"
```

---

## Task 4: Health Endpoint Test

**Files:**
- Create: `backend/tests/__init__.py`
- Create: `backend/tests/conftest.py`
- Create: `backend/tests/api/__init__.py`
- Create: `backend/tests/api/test_health.py`
- Create: `backend/pytest.ini`

**Step 1: Create test directories**

```bash
mkdir -p backend/tests/api
```

**Step 2: Create pytest.ini**

```ini
# backend/pytest.ini
[pytest]
asyncio_mode = auto
testpaths = tests
```

**Step 3: Create conftest.py**

```python
# backend/tests/conftest.py
import pytest
from httpx import AsyncClient, ASGITransport

from app.main import app


@pytest.fixture
async def client():
    """Async test client for FastAPI app."""
    async with AsyncClient(
        transport=ASGITransport(app=app),
        base_url="http://test"
    ) as ac:
        yield ac
```

**Step 4: Create empty __init__.py files**

```python
# backend/tests/__init__.py
# backend/tests/api/__init__.py
```

(Both empty)

**Step 5: Write the failing test**

```python
# backend/tests/api/test_health.py
import pytest


@pytest.mark.asyncio
async def test_health_endpoint_returns_healthy(client):
    """Health endpoint should return status healthy."""
    response = await client.get("/api/v1/health")

    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}


@pytest.mark.asyncio
async def test_root_endpoint_returns_welcome(client):
    """Root endpoint should return welcome message."""
    response = await client.get("/")

    assert response.status_code == 200
    assert "Veelocity" in response.json()["message"]
```

**Step 6: Run tests**

```bash
cd backend
source venv/bin/activate
pytest -v
```

Expected: 2 tests PASS

**Step 7: Commit**

```bash
git add backend/tests/ backend/pytest.ini
git commit -m "test(backend): add health endpoint tests

- Async test client fixture using httpx
- Test health endpoint returns healthy status
- Test root endpoint returns welcome message"
```

---

## Task 5: Flutter Project Setup

**Files:**
- Create: `frontend/` (Flutter project)
- Modify: `frontend/pubspec.yaml`
- Modify: `frontend/lib/main.dart`

**Step 1: Create Flutter project**

```bash
flutter create --org com.veesion frontend
```

**Step 2: Update pubspec.yaml dependencies**

Replace the dependencies section in `frontend/pubspec.yaml`:

```yaml
# frontend/pubspec.yaml
name: veelocity
description: Developer analytics platform measuring DORA metrics
publish_to: 'none'
version: 0.1.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^2.4.9
  dio: ^5.4.0
  fl_chart: ^0.66.0
  go_router: ^13.0.0
  shared_preferences: ^2.2.2
  intl: ^0.19.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true
```

**Step 3: Create directory structure**

```bash
mkdir -p frontend/lib/models frontend/lib/services frontend/lib/screens frontend/lib/widgets
```

**Step 4: Replace main.dart**

```dart
// frontend/lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() {
  runApp(const ProviderScope(child: VeelocityApp()));
}

class VeelocityApp extends StatelessWidget {
  const VeelocityApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Veelocity',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: const Color(0xFF1E3A5F),
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Veelocity'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
      ),
      body: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.analytics_outlined,
              size: 64,
              color: Color(0xFF1E3A5F),
            ),
            SizedBox(height: 16),
            Text(
              'Welcome to Veelocity',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: 8),
            Text(
              'Developer Analytics Platform',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

**Step 5: Get dependencies**

```bash
cd frontend
flutter pub get
```

**Step 6: Test Flutter runs**

```bash
flutter run -d chrome
```

Expected: Browser opens with "Welcome to Veelocity" screen with blue (#1E3A5F) theme

**Step 7: Commit**

```bash
git add frontend/
git commit -m "feat(frontend): initialize Flutter project

- Set up Flutter with Riverpod, Dio, fl_chart, go_router
- Primary color #1E3A5F (Veesion blue)
- Basic home screen with welcome message"
```

---

## Task 6: API Service Base

**Files:**
- Create: `frontend/lib/services/api_service.dart`
- Create: `frontend/lib/core/config.dart`

**Step 1: Create core directory**

```bash
mkdir -p frontend/lib/core
```

**Step 2: Create config.dart**

```dart
// frontend/lib/core/config.dart
class AppConfig {
  static const String apiBaseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'http://localhost:8000',
  );
}
```

**Step 3: Create api_service.dart**

```dart
// frontend/lib/services/api_service.dart
import 'package:dio/dio.dart';
import '../core/config.dart';

class ApiService {
  late final Dio _dio;

  ApiService() {
    _dio = Dio(
      BaseOptions(
        baseUrl: AppConfig.apiBaseUrl,
        connectTimeout: const Duration(seconds: 10),
        receiveTimeout: const Duration(seconds: 10),
        headers: {
          'Content-Type': 'application/json',
        },
      ),
    );
  }

  Future<Map<String, dynamic>> healthCheck() async {
    final response = await _dio.get('/api/v1/health');
    return response.data;
  }

  // Placeholder for future methods
  Future<T> get<T>(String path) async {
    final response = await _dio.get(path);
    return response.data as T;
  }

  Future<T> post<T>(String path, {Map<String, dynamic>? data}) async {
    final response = await _dio.post(path, data: data);
    return response.data as T;
  }
}
```

**Step 4: Create Riverpod provider**

```dart
// frontend/lib/services/providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'api_service.dart';

final apiServiceProvider = Provider<ApiService>((ref) {
  return ApiService();
});
```

**Step 5: Commit**

```bash
git add frontend/lib/core/ frontend/lib/services/
git commit -m "feat(frontend): add API service with Dio

- ApiService with configurable base URL
- Health check method
- Generic GET/POST helpers
- Riverpod provider for dependency injection"
```

---

## Task 7: Update CLAUDE.md with Simplified Architecture

**Files:**
- Modify: `CLAUDE.md`

**Step 1: Update CLAUDE.md to reflect simplified architecture**

Replace the content to match the new simplified design (remove Redis, Celery, K8s references, update roadmap).

Key changes:
- Remove Redis, Celery from stack
- Remove Organization/User models
- Update roadmap to 5 versions
- Note: credentials via env vars only

**Step 2: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: update CLAUDE.md with simplified architecture

- Remove Redis, Celery, Kubernetes from stack
- Single-user mode, no auth
- Credentials via environment variables
- Updated 5-version roadmap"
```

---

## Task 8: Final Verification

**Step 1: Verify Docker Compose works end-to-end**

```bash
make down  # Clean slate
make dev   # Start fresh
```

Wait for services to be healthy.

**Step 2: Verify backend health**

```bash
curl http://localhost:8000/api/v1/health
```

Expected: `{"status":"healthy"}`

**Step 3: Verify backend tests pass**

```bash
cd backend && source venv/bin/activate && pytest -v
```

Expected: All tests pass

**Step 4: Verify Flutter builds**

```bash
cd frontend && flutter build web
```

Expected: Build succeeds

**Step 5: Final commit if any cleanup needed**

```bash
git status
# If there are uncommitted changes, commit them
```

---

## Summary

After completing all tasks, v0.1 delivers:

- [x] FastAPI backend with health endpoint
- [x] Async SQLAlchemy + Alembic for PostgreSQL
- [x] Docker Compose for local development
- [x] Makefile with common commands
- [x] Flutter app with Riverpod state management
- [x] API service ready for metrics endpoints
- [x] Tests for health endpoint
- [x] Updated documentation

**Next version (v0.2):** GitHub connector implementation
